\documentclass[a4paper]{article}
\usepackage[margin=3cm]{geometry} % make margins smaller
 
\usepackage[english]{babel}
\usepackage[nottoc]{tocbibind} %Adds "References" to the table of contents
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage[colorinlistoftodos]{todonotes}

\usepackage{inconsolata}
%nice way to highlight code 
\usepackage{listings}
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
}
 
\lstset{style=mystyle}

\title{\textbf{IN4073 Embedded Real-Time Systems}}

\author{Ali Alessio Salman 4505778, \\Bastiaan Gris\`el 4090438, \\Henko Aantjes 4138899\\Team 1}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
% 10 lines, specific approach and results
% keywords: safety, reliability, stability, fast calculations
This report describes all design choices needed to fly a quadrotor (QR). The main focus of the implementation is on safety, reliability, stability and speed. Safety and reliability are implemented with many safety checks, such that no user could be harmed by unexpected QR behavior, even if the user is not totally focused on operating the QR. The user interface contributed to a complete status feedback to the user, such that the user always knows in which state the QR is and what the current control parameters are. Stability and speed have proved itself in the choice of a fast communication protocol, a strong and fast IIR and Kalman filter. This all contributed to the stage that we actually flew the QR.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}
% problem statement
%The QR that we have is useless and we need to write the software to make it connect to the PC (joystick) and to make it stable.
%add references to this [7] In4073 Resources http://www.st.ewi.tudelft.nl/~koen/in4073/Resources/. for the demo software
% the rs232 connect the pc to the fpga not to the QR
%The sections will present the software design of a QR controller.
This project is about a complete programmable QR, which has sensors (gyroscope and accelerometers) and actuators (motors), both connected via a micro controller. Also a joystick is provided, which (connected to a PC) must be used to fly the QR. The PC communicates with the FPGA by a RS232 connection. Some software and theory can be found on the resource page of the project \cite{resourcesERTS}. The goal of the project is to design the software for this QR such that it will be able to stably hover.

Section \ref{sec:arch} provides an overview of the architecture. The implementation of this architecture will be discussed in section \ref{sec:impl}. The experimental results can be found in section \ref{sec:res} and section \ref{sec:conc} holds the conclusion.

\section{Architecture}\label{sec:arch}
% all software components
The software of the project can be divided in 2 major parts: The PC-side and the QR-side. Both will be discussed in the next subsections. 
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{image/arch.png}
  \caption{The system architecture}
  \label{fig:arch}
\end{figure}

\subsection{PC} % Include how often values are sent to the QR? Joystick data that is event based
The software in the PC is responsible for passing through the user input to the QR and for showing the state of the QR to the user, thus acting as the QR control interface. The user input that must be handled by the PC-side software are joystick, keyboard and mouse events. The real-time (10Hz) feedback that is sent from the QR must be visualized to the user and important data must be logged for offline analysis. 

\subsection{X32}
The software that runs on the QR (i.e. on the X32), is responsible for keeping the QR in a safe state. This 'safe' can be either on the ground or during a flight. On the ground it must ensure that the motors RPM are zero until the user wants to switch to manual mode or if the QR is calibrated and thus ready to switch to Yaw or Full Control mode. During real flight (Full Control with lift off), the software must read the sensor input and when a non stable situation is signaled it must counteract quick enough to avoid escalation.

During the time that sensor readings are handled, the QR must process the user input after a safety check. When this input is processed it should send feedback to the user, such that the user can check the state of the QR in real time.

\section{Implementation} \label{sec:impl} % how we did it and who did what
%shall we use "we" in this section? 
At first we've discussed the overall software  architecture - ending in what is showed in Figure \ref{fig:arch} - and the protocol design. The latter has undergone different changes, the most important of which is the extension of the payload. After having a solid protocol and manual mode working, we added logging capabilities in order to study the QR sensors behavior and to develop the filters accordingly.\\
The following sections present the most significant parts of our software. At the end of the sections a diagram depicts how the software modules are related to the 2 parts of the software architecture.

\subsection{PC: User Input and Message Handling} % PC side is polling
The main program on the PC (\texttt{pc.c}) uses a polling approach to handle multiple requests. It constantly checks if any user input coming either from the keyboard or mouse has to be processed and sent to the QR. In order not to fill the queue with too many repetitive values, the PC sends the joystick data with a maximum frequency of \SI{100}{\hertz}.

Handling incoming messages is done by pushing them into a queue (see Appendix \ref{code}) in the service routine and processing them periodically in the main loop. 

\subsection{QR: Interrupt Handling} % QR side is interrupt driven except for the message handling
The program that runs on the FPGA uses interrupts to handle incoming data. The order of importance is as follows: sensor readings, serial connection incoming data and exceptions like overflow and division by zero.

The sensor readings are received with a frequency of 1250Hz. Since processing the sensor values has utmost priority; since the QR needs to fly based on these values, we have chosen to implement the filtering and control loop infrastructure in the interrupt service routine of the sensors \texttt{isr\_qr\_link}. The filtering and control loop calculations were not fast enough to be able to run at 1250Hz, without taking up to 90 percent of the execution time. So we decided to perform these calculations every 2 interrupts, making the frequency of our control loop roughly 625Hz, as shown in Figure \ref{fig:isrFreq}, the sensor readings are not received at exactly 1250Hz, therefore our control loop frequency has some variation as well.

When a new character arrives on the RS232 line, the interrupt handler pushes the messages in a fifo queue. Then, similar to what happens on the PC, a polling approach takes care of handling the packets accordingly to the protocol, which is explained in the following subsection. In order to ensure a correct process of the packets, interrupts are temporary disabled when processing the messages in the fifo queue.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{image/isr_qr_link_time.png}
  \caption{The time between two sensor values is not constant.}
  \label{fig:isrFreq}
\end{figure}

\subsection{Communication} % The communications that are defined
\subsubsection{Protocol Design}
The packet for each message sent between the PC and the X32 soft core is chosen to be 32 bits. This choice of a small packet is made because this could give the choice of sending only short events at a high frequency, without for example having to send the complete joystick state every event. As shown in Figure \ref{fig:packet1} and \ref{fig:packet2}, the packet is composed of 3 parts: \textit{(i)} the first byte represents the preamble of the packet, which indicates the control value (i.e. what the message is for); \textit{(ii)} the next 2 bytes carry the actual payload that according to the kind of information can be a char, int8\_t, uint8\_t, int16\_t or uint16\_t; \textit{(iii)} the last byte is reserved for the checksum.

Since the system is a \emph{real-time} system, no special attention is paid to the packet loss because the information in each packet is highly time-dependent and by the time the lost packet would be re-transmitted the information would be outdated.

The checksum is used to prevent execution of the wrong commands that could cause an immediate crash of the QR. Therefore, both the FPGA and the PC are constantly verifying if the checksum is correct before actually processing the packet. More precisely, they compute the checksum on the first 3 bytes and compare it with the packet checksum: if the checksum is correct the packet can be forwarded for the following processing; if not, the first byte is discarded and another byte is peeked from the queue (i.e. 1 byte-shift in the packet) to recompute the checksum. Hence, the stream of messages can be synchronized even after that one or several bytes are lost. 

\subsubsection{Protocol Implementation}
All the different types of messages that can be sent between the 2 parts (see fig.\ref{fig:packet1} and fig.\ref{fig:packet2}) are defined in \texttt{types.h}. Those which have to be sent by pressing the keyboard respect all the mapping requirements of the assignment. 

The checksum is calculated on 24 bits of data: control + payload. Due to the limited size, an 8 bits checksum can face 2 different issues: being not capable to detect byte disorder and producing a small universe of values, thus higher probability of collision. Therefore it has been implemented adapting the Fletcher algorithm to an 8 bit checksum. The Fletcher checksum tackles both these problems while remaining easy to implement. The order sensitivity is introduced because once a block is added to the first sum it will be also repeatedly added to the second one. So if a byte is shifted of one position it will be added one more/fewer time to the final sum. However, the universe remains limited to 255 values since, as pointed out before, only 8bits are available. Our implementation is efficient and thus extensible to protocols with bigger payloads.

The abstract data type used to implement the stream of messages is a circular queue, whose implementation is defined in the \texttt{fifo.h} file. In particular a peek function which returns the value of an element in the queue without removing it is provided, as well as all the other basic functions. The implementation of this algorithm can be seen in Appendix \ref{code}.

\vspace{0em}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{image/packetsPC_QR2_0.png}
  \caption{The messages from the PC to the QR}
  \label{fig:packet1}
\end{figure}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{image/packetsQR_PC2_0.png}
  \caption{The messages from the QR to the PC}
  \label{fig:packet2}
\end{figure}

\subsection{Logging} 
 Logging is crucial to gather the data necessary to design the filters, inspect crashes or profiling certain performance. Hence, all flight parameters are logged every control loop and all events, like mode change and user input, are logged whenever they arise. They're first stored in the RAM and then printed to two different files\footnote{\texttt{data\_log.txt, event\_log.txt}. The format can be found in \texttt{logging.h}}.
Normally the user can - after landing and only in safe mode - ask the most recent 10 secs log from the QR to analyze the flight. However, by pressing key \textbf{\texttt{'s'}} it is possible to reset the logs and store log data in those particular next 10 secs. This is useful, for example, to analyze data during particular movements of the QR. In MATLAB these files can be visualized as can be seen in the mode event log of Figure \ref{fig:logmode} or the filter parameter log of Figure \ref{fig:kaleman} (scaled in MATLAB to degree angles).
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.6\textwidth]{image/logMode.png}
  \caption{A typical log of mode changes}
  \label{fig:logmode}
\end{figure}

\subsection{Filtering} % keyword: fast 
Filtering can be divided in the filter of yaw control and the filter of roll and pitch control. For yaw control an infinite impulse response filter (\texttt{IIR}) is chosen. The reason lies in the high speed of this type of filter. Compared to a finite impulse response filter, this filter can achieve the same bandwidth requirements with a lower order. Because of the high speed, the main disadvantage (the phase delay) of this filter is not of great influence. The transfer function of the first-order filter is straightforward: 
\[H(z) = \frac{1}{1 - a z^{-1}}\]
The design of this filter is a bit harder, because a set of requirements do not map directly to a useful parameter 'a' of the filter. With a set of QR sensor traces and the help of MATLAB the right 'a' value was chosen to be $1/8$. The value of 'a' was chosen to be of the form $1/2^b$, such that the complete filter can be implemented solely with additions and bit shifts.

A Kalman filter is used for roll and pitch control. Speed again was the main focus: the sooner the act to resolve the error, the smaller the error will be. It is better to have a clumsy but fast controller, than a precise but slow controller. The implementation of the Kalman filter is just a normal one, except for the following adjustments:
\begin{itemize}
\setlength\itemsep{0em}
\item The filter needs high precision, 14 bits fixed point numbers are used.
\item Most parameters were chosen to be factors of 2. Not a single division is performed.
%\item The frequency is not constant. The Kalman filtering happens inside the isr\_qr\_link routine and this interrupt is not called with a constant pace. The fluctuation of the frequency is not large as can be seen in Figure \ref{fig:isrFreq}. 
\item Because of the fixed point representation, the mapping from the accelerometer angle to the integrated gyroscope angle was not straightforward. The ratio has been found by comparing the traces in MATLAB. In Figure \ref{fig:kaleman} this ratio is used and the typical difference between the two sensors can be seen.
\item The fixed point representation introduced rounding errors, so these needed to be tackled.
\end{itemize}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{image/gyro_and_accel.png}
  \caption{The integrated gyro data versus the accelerometer data.}
  \label{fig:kaleman}
\end{figure}

\subsection{User Interface \& Telemetry} %keyword modular - let the user have complete control over the QR
%something like: %intro-outgoing: user can change mode, can ask logging, can tune parameters, on the fly - incoming: real time data is sent from the QR every 100ms, division between data retrieval and visual: drawings and display of data -> our software is modular    perfect!
% we need a picture here i think, bastiaan can you write a fancy text about your design "less is more"
A simple but effective text-based interface has been developed in order to show relevant information about the QR (see Figure \ref{fig:ui}). This information is sent from the QR to the PC at a frequency of 10Hz and includes: mode, joystick data, sensor values, the angles of the QR, the three outputs of the control loops, some communication statistics and the actual RPM of the four motors. In addition to this, several parameters can be tuned on the fly. These include: all P-values of the controllers, the filter parameters\footnote[1]{The reason that there are three filter parameters is that we have also experimented with filtering with the IIR filter before doing the Kalman.} and the joystick sensitivity. The interface can also show the following on-demand data by pressing certain keys:
\begin{itemize}
\setlength\itemsep{-0.3em}% this already saves some space ;)
\item[\textbf{m}] Show all the values that have to do with motor RPM, including the pre-defined offset
\item[\textbf{f}] Show the intermediate outputs of the Yaw Control filtering
\item[\textbf{g}] Show the intermediate outputs of the Kalman filter
\item[\textbf{b}] Ask the bias of the sensors (the calibrated values)
\item[\textbf{x}] Transfer the sensor log (can only be done in Safe mode)
\item[\textbf{s}] Reset the sensor log (insert the next sensor values starting at array index 0)
\end{itemize}
By keeping the visual code and the code that updates the data separated\footnote[2]{see \texttt{send\_feedback(), packet\_received() and drawing functions}}, it was very easy to add new functionality to the interface. This modularity enables us to quickly expand the interface when needed.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{image/UI.png}
  \caption{The user interface that is shown on the PC.}
  \label{fig:ui}
\end{figure}

\subsection{Safety}
Safety and reliability were key in this project. The rigorous safety requirements posed in the assignment were implemented step by step and tested at the beginning of each practical session to ensure correct operation. One of the major safety components was the selective mode change as shown in Figure \ref{fig:modes}. Before transitioning from one mode to another (except for Panic), the QR has to be put into Safe mode. In this mode, the QR does not actuate the motors. In addition, the QR does not actuate the motors and resets the RPM and offset values to be zero when changing mode. In order to change the mode to either Yaw control or Full Control, the QR needs to be calibrated first. While in Manual, Yaw or Full Control mode the QR may not actuate any motor until the lift is nonzero. Furthermore, all definitive safety checks are performed on the QR itself. There might be additional safety checks implemented on the PC side, but they are redundant and only serve a way to prevent sending information to the QR that will be regarded anyways (such as an invalid mode change).

As a safety measure, the PC will make sure that it sends a packet to the QR at least every 150ms. If this frequency is not obtained by the regular packet transmission, a keep-alive packet is sent. The QR has a timer which is reset when a new character has passed over the RS232 line from the PC to the QR. If this timer exceeds a certain threshold (500ms), then it is assumed that connection to the PC is lost and the QR will transition into Panic mode. In Panic mode, the motors are given a fixed RPM of 400 for a duration of 2000ms. Although the final implementation followed the one outlined in the report, we found it more useful to just set the RPM to zero when going into Panic mode as: 1) we did never fly very high so a drop would not have caused damage to the QR and 2) we often ended up with a QR that is already on the ground while still spinning its rotors which could then hit other objects on the ground.

The LEDs on the QR are used to show the operational status of the QR. One LED should constantly blink with a frequency of 1Hz and two other LEDs are on as long as the communication to the PC and respectively to the on board micro controller are working. 
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.8\textwidth]{image/Mode_diagram2_1.png}
  \caption{Mode diagram}
  \label{fig:modes}
\end{figure}

\subsection{Overall software architecture UML}
The colors group modules according to their relations. Total size of C code: 2944 lines.\\
%\hspace{-7em}
\centerline{\includegraphics[width=1.0\paperwidth,height=14cm,keepaspectratio]{image/cropped2.pdf}}

\subsection{Work division}
We divided the task accordingly to the following: 
\begin{itemize}
\setlength\itemsep{0em}
%also Alessio: errors, checksum, motors and change mode, refactoring too , Henko handle JS and Key at the beginning, definition of messages and then also QR side with filtering
%bastiaan specific on communication and refactoring of UI
\item Ali Alessio Salman worked mostly on logging and real-time data retrieval. Thanks to his work we could analyze the behavior of the QR offline. Other tasks were implementing the checksum and handling communication errors, motor safety, mode control and general refactoring.
\item Bastiaan Gris\`el worked mostly on the communication and (re)designing the user interface. Thanks to his software engineering methods the codebase is clear and modular. Due to the easy to use user interface we could test and modify the parameters on the fly.
\item Henko Aantjes worked mostly on filter techniques. Thanks to the fast and reliable filter the QR could fly in full control mode. Other tasks were the initial implementation of the user input (joystick, keyboard and mouse input), the initial implementation of messages and the offline processing of flight logs.
\end{itemize}
Although we divided the tasks, a constant collaboration and understanding on others' work was always present. This made it possible to find errors and possible optimizations in an early stage.

\section{Experimental results}\label{sec:res}
% list capabilities of your demonstrator
\begin{itemize}
\setlength\itemsep{0em}
 \item Safety measures are satisfied: the application starts in the safe state. In safe mode the motor RPMs are always set to zero and it is only possible to switch mode if the joystick is set to zero too.
\item Emergency situations are properly handled: the panic button mapped on the joystick forces the system to immediately go to panic, thus to safe. Furthermore, panic mode is always called whenever the connection is cut off for more than a pre-defined amount of ms. This guarantees a landing.
\item Reliable communication: the transmission between the QR and the PC is reliable, responsive and robust to errors thanks to our protocol. Two LEDs on the FPGA are on when the links are properly functioning.
\item Rich Interface: the UI effectively provides real-time data visualization and through on-the-fly tuning gives a complete control over the filtering and the sensitivity of the joystick.
\item Manual mode: the QR can be successfully controlled with the joystick. Engines are responsive. 
\item Calibration mode: sensors bias are properly stored during calibration and thus can be effectively used for future signal processing.
\item Yaw Control mode: the QR counteracts external interference e.g. tapping the QR. A desired yaw rate can be sent via the joystick.
\item Full Control mode: after multiple parameter (re)tune phases, the QR was stable enough to make it hover and after the TA's approval we all got the chance of flying the QR. After multiple successful short flights we painfully discovered a bouncing behavior of the QR. When the QR bounces once on the ground, then it comes into a state in which it jumps and re-bounces multiple times. The best way to stop it was to go out of full control mode. The actual cause of this behavior is unknown and might provide a lead for further research. \footnote{See the QR fly here: http://tiny.cc/flyingQR}

\end{itemize}

\subsection{Timings}
A quick response is crucial for the controllability of the QR, so this section provides a timing analysis of the most crucial system block, the control loop. The control loop is executed with a frequency of around 625 Hz, which means that the loop must be executed in less then 1500 us. The remaining time must be as large as possible such that also the other parts of the code (like user control) have enough execution time.
In table \ref{tab:timings} the time in $\mu$s can be found of the major parts of the control loop. 

\begin{table}[h!]
\centering
\caption{Time analysis}
\label{tab:timings}
\begin{tabular}{l|l}
       & \textbf{Time {[}$\mu$s{]}} \\ \hline
Read sensors              & 21      \\
Yaw control                 & 47        \\
Roll/pitch control  together & 291      \\
Safety and actuation      &  177    \\
Logging                   &  157  \\ \hline
Total control loop time & 693
\end{tabular}
\end{table}


\section{Discussion}\label{sec:conc}
All three of us look back on a successful project. We have done our best to keep things as simple as possible and this payed off. Where we saw other groups struggling with complicated floating point libraries, our fixed-point arithmetic worked incredibly well and executed in a fraction of the time. And while other groups had chosen to implement fancy communication protocols with variable length packets and complex data transfer methods, our fixed-length protocol was simple, clean and elegant and provided all necessary functionality without much overhead. Ultimately, this approach enabled us to work fast and get the QR to hover.

Another key takeaway in embedded systems environments is that you cannot take reliability of the hardware for granted. We have spent half of a practical session with a broken RS232 cable and couldn't find out why our QR kept going into Panic mode.

Working on this project has been a learning experience for all of us since this project combines software engineering, embedded systems programming and signal processing. These different aspects were well represented in our group, which enabled us to learn from each other.

\subsection{Recommendations}
There is lots of room for future work. First of all, it would be useful to find out where the bouncy behavior of the QR originates from. The behavior seems to occur when using flexible landing rods. It also would be convenient to extend the implementation to support wireless communication. This might require a more elaborate protocol since packet loss will be higher. Instead of using a Kalman filter, a complementary filter is also discussed in literature \cite{higgins1975comparison}. This filter is easier to implement and performs roughly the same as a Kalman filter.

\appendix
\section{Code}
\label{code}
% component code for those components you wish to feature
%if we need it
\begin{lstlisting}[language=C, caption=Protocol implementation]
void check_for_new_packets(Fifo *q, void (*callback)(char, PacketData), void (*error)()){
	while(fifo_size(q) >= 4) { // Check if there are one or more packets in the queue
		char control;
		PacketData data;
		char checksum;

		fifo_peek_at(q, &control, 0);
		fifo_peek_at(q, &data.as_bytes[0], 1);
		fifo_peek_at(q, &data.as_bytes[1], 2);
		fifo_peek_at(q, &checksum, 3);

		if(!check_packet(control,data,checksum)) {
			// If the checksum is not correct, pop the first message off the queue and repeat the loop
			char c;
			fifo_pop(q, &c);

			error();
		} else {
			// If the checksum is correct, pop the packet off the queue and notify a callback
			char c;
			fifo_pop(q, &c);
			fifo_pop(q, &c);
			fifo_pop(q, &c);
			fifo_pop(q, &c);

			callback(control, data);
		}
	}
}
\end{lstlisting}

\bibliography{references} 
\bibliographystyle{apalike}

\end{document}
